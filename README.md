## Запус сервиса
### docker compose up
1. Склонировать проект на вашу машину:
`git clone https://github.com/gold-boy229/PR-Reviewer-Assignment-Service.git .`
2. Создать .env файл с переменными, указанными в empty.env одним из способов:
    1.  На Windows: `copy empty.env .env`
    2.  На Linux: `cp empty.env .env`
    3. Свой вариант
3. Опицонально. Задайте нужные вам значения переменным в .env файле
4. Выполните команду `docker compose up`

------------

### Вопросы и принятые решения

#### Все роуты
##### Вопрос/проблема:
Изначальная API спецификация не давала возможности явно вернуть сообщение об ошибке, будь то `bad_request` или `internal_server_error`.
##### Принятое решение:
Добавил каждому роуту коды ответов для `400` и `500` ошибок. 
Также добавил в перечисление кодов ошибок: `BAD_REQUEST` и `INTERNAL_SERVER_ERROR`

#### Роут /team/add
##### Вопрос/проблема:
Не совсем понимаю что имеется ввиду под "создаёт/обновляет пользователей" в спецификации API 
>summary: Создать команду с участниками (создаёт/обновляет пользователей)

##### Принятое решение:
В своем решении считаю, что пользователя можно уникально идентифицировать через `user_id`, а не через пару (`user_id`, `team_name`).
Таким образом, роут `team/add` создает команду и добавлять НОВЫХ пользователей. Если хоть один пользователь уже есть в БД/ запросе, то это специфичная ошибка
**Краткое описание нового API /team/add:**
400 код:
- Нет какого-то поля в теле запроса
- Пустой список участников команды
- В запросе повторяются ID-шники участников
- Попытка создать уже существующую команду
- Среди участников новой команды есть те, кто уже участник другой команды

500 код:
- Произошла какая-то ошибка во время работы на слое репозитория с БД

201 код:
- Ничего из вышеописанного не произошло и команда успешно создалась

#### Роут /pullRequest/reassign
##### Вопрос/проблема:
В API метод описан так:
> summary: Переназначить конкретного ревьювера на другого из его команды 

Не понятно, можем ли мы, выполняя эту операцию, назначить ревьюером автора этого PR'а
##### Принятое решение:
В моем решении, так делать нельзя. 
То есть, автор PR'а не может стать ревьюером этого PR'а

-----
### Выполнение дополнительного задания
Изначально ходел делать этот пункт задания: 
>Добавить простой эндпоинт статистики (например, количество назначений по пользователям и/или по PR).

Посидев и подумав над вариантами таких эндпоинтов для статистики ничего особо полезного не смог придумать. 
Поэтому я решил поставить себя на место руководителя команды, который будет пользоваться этим сервисом: какие проблемы будут его беспокоить и как он будет их решать, используя этот сервис.
Вот перечень функционала, который мне (как воображаемому руководителю команды) хотелось бы видеть:
1. **Эндпоинт для нахождения PR-ов, у которых сейчас нет активных ревьюеров.** 
Как руководителю команды, ты хочешь, чтобы PR-ы закрывались, а если у какого-то PR-a нет активных ревьюеров, то он не закроется (пока ревьюеры не станут активными). Такие PR-ы плохие.

	Этот эндпоинт решает лишь часть проблемы: находить список плохих PR-ов

	Этот список можно разбить на две группы:
	  1. PR-ы, в которых есть сколько-то неактивных ревьюеров. 
	  В этом случае у тебя есть эндпоинт `/pullRequest/reassign`, которым можно заменить неактиного ревьюера на активного.
	  
	  2. PR-ы, в которых не хватает какого-то количества ревьюеров (0..2).
	  В этом случае ты хочешь добавить новых ревьюеров, но не можешь...

2. **Эндпоинт для назначения новых ревьюеров на проверку PR-a**
Идея назначения ревьюеров такая же как и при создании PR-a через `/pullRequest/create`:
Хотим назначить активных участников из команды автора на заданный PR. 
После операции, на проверку PR-а должно быть назначено до 2 ревьюеров

----
В целом, я считаю, что эти два эндпоинта значительно расширяют возможности сервиса и значительно упрощают жизнь руководителя команды.

Еще думал о добавлении эндпоинта, с помощью которого можно смотреть сколько открытых PR-ов закреплено за каждым членом команды. 
Тоже непрохой вариант для развития сервиса, более равномерного распределения нагрузки между участниками команды. 
Но, думаю что более красивым решением неравномерного распределения является переработка алгоритма назначения ревьюеров на PR'ы.

**Описание этих эндпоинтов добавил в `openapi.yaml`**

_____
### Работа с миграциями 
#### Работа с миграциями через Visual Studio Code 
Добавил задачи в Visual Studio Code (далее VSC) (tasks), с помощью которых можно:
1. Создавать новую миграцию (.up и .down), с нужным вам названием - "Create Migration";
2. Применить/отменить миграцию/миграции - "Run migrations". Эта команда ожидает два ввода: 
	1. Тип миграции: up|down (обязательное поле);
	2. Количество миграций, которые нужно выполнить (опциональное поле).

Запуск задачи в VSC:
1. Ctrl + Shift + P;
2. Tasks: Run Task;
3. Выбрать из списка нужный task или ввести его назавние.

#### Работа с миграциями через Command Line Interface
1. Создать новую миграцию - `migrate create -ext sql -dir ./db/migrations <new_migration_name>`;
2. Запустить миграцию:
	1. Через рукописный cli-migrator.go - `go run ./db/cli-migrator.go up|down [N]`. Принцип работы: 
		1. Читает переменные окружения из .env файла, чтобы подключиться к БД;
		2. Читает аргументы командной строки;
		3. Выполняет миграции.
    2. Через командную строку - `migrate -source file://./db/migrations -database "postgres://<DB_USER>:<DB_PASSWORD>@<DB_HOST>:<DB_PORT>/<DB_NAME>?sslmode=disable" up|down [N]`. Принцип работы такой же как в предыдущем пункте. Отличие только в том, что тут вам самим нужно подставлять значения переменных в шаблон URL'a БД. 
